<html>
    <head>
      <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
      <meta charset="utf-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0">      
      <style type="text/css">

    body {
      margin: 0;
      font-family: Arial, sans-serif;
    }

    header {
      background-color: #1d3557;
      color: white;
      padding: 15px 20px;
      text-align: center;
      font-size: 24px;
      font-weight: bold;
    } 

    #dataToggleContainer {
      background: #f1f1f1;
      padding: 10px;
      text-align: center;
    }

    #dataToggleContainer label {
      margin: 0 15px;
      font-size: 16px;
      cursor: pointer;
    }

    #map {
          height: calc(100vh - 100px); /* adjust for header + toggle bar */
          width: 100%;
    }
    body {
        display: flex;
        flex-direction: column;
        min-height: 100vh;
    }

    #footer {
    position: fixed;
    bottom: calc(30px + 0.5rem);
    left: 50%;
    transform: translateX(-50%);
    text-align: center;
    font-size: 20px;
    font-family: Lato, sans-serif;
    color: #4C4A57;
    font-style: light;
    width: 100%;
    }

    p {
    font-family: 'Lato', sans-serif;
    font-weight: 300;
    font-size: 16px;
    }

    #searchContainer {
        display: flex;
        justify-content: center;
        align-items: center;
        margin: 10px auto;
        gap: 8px;
        max-width: 400px;
    }

    #citySearch {
        flex: 1;
        padding: 8px 12px;
        border: 1px solid #ccc;
        border-radius: 6px;
        font-size: 14px;
    }

    #searchBtn {
        padding: 8px 16px;
        background-color: #004080; /* match header/nav blue */
        color: #fff;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        transition: background 0.2s;
    }

    #searchBtn:hover {
        background-color: #0059b3; /* lighter hover blue */
    }

      </style>
      <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
      <title>World Cities Map</title>
    </head>
  <body>
    <header> World Map Viewer </header>
    <!--radio buttons-->
    <div id="dataToggleContainer">
        <label>
        <input type="radio" name="dataToggle" value="cities" checked /> Cities
        </label>
        <label>
        <input type="radio" name="dataToggle" value="railways" /> Railway Lines
        </label>
        <label>
          <input type="radio" name="dataToggle" value="countries"> Countries
        </label>
    </div>
    <!-- Search bar (hidden by default unless cities is selected) -->
    <div id="citySearchContainer" style="margin: 10px 0;">
      <input type="text" id="citySearch" placeholder="Enter city name..." style="padding:5px; width:200px;" />
      <button id="searchBtn" onclick="searchCity()">Search</button>
    </div>    
    <div id="map"></div>
     <div id="footer">
        Built on Oracle Databases and Flask
     </div>
    <div id="loading" style="display: none; position: fixed; top: 50%; left: 50%; transform: translateX(-50%);
        background-color: #333; color: #fff; padding: 10px 20px; border-radius: 5px; z-index: 1000;">
    </div>     
   <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script> 
   <script>
    // Initial map settings
    const initialLat = 20;
    const initialLng = 0;
    const initialZoom = 2;

    const cityIcon = L.icon({
      iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png', // red icon example
      iconSize: [20, 30],   // size of the icon (width, height) - smaller than default
      iconAnchor: [10, 30], // point of the icon which will correspond to marker's location
      popupAnchor: [0, -28] // where popups open relative to the iconAnchor
    });

    const map = L.map('map',{worldCopyJump:true}).setView([initialLat, initialLng], initialZoom);    
    
    const baseLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);
  
    let currentLayerGroup = L.layerGroup().addTo(map);

    const resetControl = L.control({ position: 'topright' });

    resetControl.onAdd = function () {
        const div = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
        div.innerHTML = '<a href="#" title="Reset Zoom" style="padding: 5px;">‚ü≥</a>';
        div.style.background = 'white';
        div.style.cursor = 'pointer';
        div.onclick = function () {
        map.setView([initialLat, initialLng], initialZoom);
        };
        return div;
    };

    resetControl.addTo(map);
 
  // Show/hide search bar based on selected dataset
  document.querySelectorAll("input[name='dataToggle']").forEach(radio => {
    radio.addEventListener("change", function() {
      const searchContainer = document.getElementById("citySearchContainer");
      if (this.value === "cities") {
        searchContainer.style.display = "block";
      } else {
        searchContainer.style.display = "none";
      }
    });
  });

  // Ensure correct initial state
  if (document.querySelector("input[name='dataToggle']:checked").value === "cities") {
    document.getElementById("citySearchContainer").style.display = "block";
  } else {
    document.getElementById("citySearchContainer").style.display = "none";
  }

  let cityLayer = null;  // keep reference to highlight layer
  // Placeholder search function
  async function searchCity() {
    const city = document.getElementById("citySearch").value;
    if (!city) {
      alert("Please enter a city name!");
      return;
    }
    console.log("Searching city:", city);
    // TODO: hook this up to your /search_city API
    try {
      const response = await fetch(`/search_city?q=${encodeURIComponent(city)}`);
      const data = await response.json();
      if (response.ok) {
        console.log("City found:", data);
        // TODO: Display the city on the map
      } else {
        throw new Error(data.error || "Unknown error");
      }

      //Remove previous highlight if exists
      if (cityLayer) {
        map.removeLayer(cityLayer);
      }

      // Add new highlight
      /*cityLayer = L.geoJSON(data, {
      style: {
        color: "red",
        weight: 3,
        fillColor: "yellow",
        fillOpacity: 0.6
      }
    }).addTo(map);*/

      cityLayer = L.geoJSON(data, {
      style: {
        color: "red",
        weight: 3,
        fillColor: "yellow",
        fillOpacity: 0.6
      }
    });
    currentLayerGroup.addLayer(cityLayer);

    //zoom map to bounding box
    if (data.bbox) {
      const bounds = [
        [data.bbox[1], data.bbox[0]], // [miny, minx]
        [data.bbox[3], data.bbox[2]]  // [maxy, maxx]
      ];
      map.fitBounds(bounds, { maxZoom: 8, padding: [50, 50] }); // adjust maxZoom as needed
    }    
    } catch (error) {
      console.error("Error searching city:", error);
      alert("‚ùå " + error.message);
    }

  }

  function showLoading(isLoading,type) {
    const loader = document.getElementById("loading");
    loader.style.display = isLoading ? "block" : "none";
    loader.innerHTML = isLoading ? `‚è≥ Loading ${type} data...` : "";
  }

 
function loadData(type) {
  showLoading(true, type);  // Show loader
  currentLayerGroup.clearLayers();  // Clear existing layers

  const endpoint = type === "cities" ? "/cities" :
                   type === "countries" ? "/countries" :
                   "/railways";

  if (type === "cities") {
    // Standard full JSON load
    fetch(endpoint)
      .then(response => {
        if (!response.ok) throw new Error(`Failed to fetch ${type}`);
        return response.json();
      })
      .then(data => {
        showLoading(false, type);

        data.forEach(city => {
          L.marker([city.latitude, city.longitude], { icon: cityIcon })
            .bindPopup(`<b>${city.name}</b><br>Population: ${city.population}`)
            .addTo(currentLayerGroup);
        });
      })
      .catch(err => {
        showLoading(false, type);
        alert("‚ùå Unable to load cities: " + err.message);
      });

  }else if (type === "countries") {
    // Countries as polygons
    fetch(endpoint)
      .then(response => {
        if (!response.ok) throw new Error(`Failed to fetch ${type}`);
        return response.json();
      })
      .then(data => {
        showLoading(false, type);

        L.geoJSON(data, {
          style: {
            color: "grey",
            weight: 2,
            fillColor: "lightblue",
            fillOpacity: 0.4
          },
          onEachFeature: function(feature, layer) {
            const props = feature.properties;
            layer.bindPopup(`<b>${props.name_long}</b> (${props.iso_a3})<br>Sovereignty: ${props.sovereignt}`);
          }
        }).addTo(currentLayerGroup);

        // Fit map to countries
        //const bounds = L.geoJSON(data).getBounds();
        //map.fitBounds(bounds, { maxZoom: 6, padding: [50, 50] });
        map.setView([initialLat, initialLng], initialZoom);
      })
      .catch(err => {
        showLoading(false, type);
        alert("‚ùå Unable to load countries: " + err.message);
      });
  }
}

function loadRailwaysStreamed() {
  showLoading(true, 'railways');
  currentLayerGroup.clearLayers();

  fetch('/railways')
    .then(response => {
      if (!response.ok) {
        throw new Error("Failed to fetch railways");
      }

      const reader = response.body.getReader();
      const decoder = new TextDecoder("utf-8");
      let buffer = "";

      function readChunk() {
        return reader.read().then(({ done, value }) => {
          if (done) {
            showLoading(false, 'railways');
            console.log("‚úÖ Stream complete");
            return;
          }

          buffer += decoder.decode(value, { stream: true });

          // NDJSON => split by line
          let lines = buffer.split("\n");
          buffer = lines.pop(); // Keep partial line if any

          lines.forEach(line => {
            if (line.trim()) {
              try {
                const collection = JSON.parse(line);
                console.log("üìå FeatureCollection chunk:", collection);

                if (collection.type === 'FeatureCollection' && Array.isArray(collection.features)) {
                  collection.features.forEach(feature => {
                    const coords = feature.geometry.coordinates;
                    const flippedCoords = coords.map(coord => [coord[1], coord[0]]);
                    const polyline = L.polyline(flippedCoords, {
                      color: 'red',
                      weight: 2
                    }).bindPopup(`
                      <b>${feature.properties.id}</b><br>
                      ${feature.properties.featurecla}<br>
                      ${feature.properties.part}<br>
                      ${feature.properties.continent}
                    `);
                    currentLayerGroup.addLayer(polyline);
                  });
                } else {
                  console.warn("‚ö†Ô∏è Skipped non-FeatureCollection:", collection);
                }

              } catch (err) {
                console.error("‚ùå JSON parse error:", err);
              }
            }
          });

          return readChunk();
        });
      }

      return readChunk();
    })
    .catch(err => {
      showLoading(false, 'railways');
      alert("‚ùå Stream error: " + err.message);
    });
}


    // Initial load
    loadData("cities");  

    // Event listener for radio buttons
    document.querySelectorAll('input[name="dataToggle"]').forEach(radio => {
      radio.addEventListener('change', function() {
        const selectedType = this.value;
        if (selectedType == "railways") {
          loadRailwaysStreamed(); // Use streamed loading for railways
        } else {
          loadData(selectedType); // Standard loading for cities
        }
      });
    });

  </script>
  </body>
</html>